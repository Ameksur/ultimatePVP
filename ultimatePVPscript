print("ultimatePVP")
print("by:Ameksur")

local ultimatePVP = Instance.new("ScreenGui")
local Gui = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local UIGradient = Instance.new("UIGradient")
local Warp = Instance.new("Frame")
local name = Instance.new("TextLabel")
local UICorner_2 = Instance.new("UICorner")
local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
local Functions = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local byAmeksur = Instance.new("TextLabel")
local UICorner_4 = Instance.new("UICorner")
local UITextSizeConstraint_2 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
local ScrollingFrame = Instance.new("ScrollingFrame")
local SpeedBost = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local UITextSizeConstraint_3 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
local AutoHit = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")
local UITextSizeConstraint_4 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
local DoubleJump = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local UITextSizeConstraint_5 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_5 = Instance.new("UIAspectRatioConstraint")
local ESPplayers = Instance.new("TextButton")
local UICorner_8 = Instance.new("UICorner")
local UITextSizeConstraint_6 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_6 = Instance.new("UIAspectRatioConstraint")
local ESPinfo = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local UITextSizeConstraint_7 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_7 = Instance.new("UIAspectRatioConstraint")
local XRay = Instance.new("TextButton")
local UICorner_10 = Instance.new("UICorner")
local UITextSizeConstraint_8 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_8 = Instance.new("UIAspectRatioConstraint")
local AntiRagdoll = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local UITextSizeConstraint_9 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_9 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_10 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_11 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_12 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_13 = Instance.new("UIAspectRatioConstraint")
local Button = Instance.new("Frame")
local UICorner_12 = Instance.new("UICorner")
local UIGradient_2 = Instance.new("UIGradient")
local GuiMenu = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")
local UITextSizeConstraint_10 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_14 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_15 = Instance.new("UIAspectRatioConstraint")
local info = Instance.new("Frame")
local UICorner_14 = Instance.new("UICorner")
local UIGradient_3 = Instance.new("UIGradient")
local Warp_2 = Instance.new("Frame")
local UICorner_15 = Instance.new("UICorner")
local name_2 = Instance.new("TextLabel")
local UICorner_16 = Instance.new("UICorner")
local UITextSizeConstraint_11 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_16 = Instance.new("UIAspectRatioConstraint")
local Income = Instance.new("TextLabel")
local UICorner_17 = Instance.new("UICorner")
local UITextSizeConstraint_12 = Instance.new("UITextSizeConstraint")
local UIAspectRatioConstraint_17 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_18 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_19 = Instance.new("UIAspectRatioConstraint")

--Properties:

ultimatePVP.Name = "ultimatePVP"
-- ИЗМЕНЕНО: Родитель изменен на CoreGui вместо PlayerGui
ultimatePVP.Parent = game:GetService("CoreGui")
ultimatePVP.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Gui.Name = "Gui"
Gui.Parent = ultimatePVP
Gui.AnchorPoint = Vector2.new(0.5, 0.5)
Gui.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Gui.BorderColor3 = Color3.fromRGB(0, 0, 0)
Gui.BorderSizePixel = 0
Gui.Position = UDim2.new(0.5, 0, 0.5, 0)
Gui.Size = UDim2.new(0.165513784, 0, 0.509823799, 0)

UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = Gui

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(220, 220, 220)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(40, 40, 40))}
UIGradient.Offset = Vector2.new(0, 0.300000012)
UIGradient.Rotation = 90
UIGradient.Parent = Gui

Warp.Name = "Warp"
Warp.Parent = Gui
Warp.AnchorPoint = Vector2.new(0.5, 0.5)
Warp.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Warp.BackgroundTransparency = 1.000
Warp.BorderColor3 = Color3.fromRGB(0, 0, 0)
Warp.BorderSizePixel = 0
Warp.Position = UDim2.new(0.5, 0, 0.5, 0)
Warp.Size = UDim2.new(0.895522654, 0, 0.930232644, 0)

name.Name = "name"
name.Parent = Warp
name.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
name.BackgroundTransparency = 0.850
name.BorderColor3 = Color3.fromRGB(0, 0, 0)
name.BorderSizePixel = 0
name.Size = UDim2.new(1, 0, 0.180000007, 0)
name.Font = Enum.Font.FredokaOne
name.Text = "ultimatePVP"
name.TextColor3 = Color3.fromRGB(110, 210, 240)
name.TextScaled = true
name.TextSize = 30.000
name.TextWrapped = true

UICorner_2.CornerRadius = UDim.new(0, 10)
UICorner_2.Parent = name

UITextSizeConstraint.Parent = name
UITextSizeConstraint.MaxTextSize = 30

UIAspectRatioConstraint.Parent = name
UIAspectRatioConstraint.AspectRatio = 3.456

Functions.Name = "Functions"
Functions.Parent = Warp
Functions.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
Functions.BackgroundTransparency = 0.850
Functions.BorderColor3 = Color3.fromRGB(0, 0, 0)
Functions.BorderSizePixel = 0
Functions.Position = UDim2.new(0, 0, 0.215000004, 0)
Functions.Size = UDim2.new(1, 0, 0.78642863, 0)

UICorner_3.CornerRadius = UDim.new(0, 10)
UICorner_3.Parent = Functions

byAmeksur.Name = "by: Ameksur"
byAmeksur.Parent = Functions
byAmeksur.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
byAmeksur.BackgroundTransparency = 0.800
byAmeksur.BorderColor3 = Color3.fromRGB(0, 0, 0)
byAmeksur.BorderSizePixel = 0
byAmeksur.Position = UDim2.new(0.055555556, 0, 0.862851918, 0)
byAmeksur.Size = UDim2.new(0.888888896, 0, 0.0908265188, 0)
byAmeksur.Font = Enum.Font.FredokaOne
byAmeksur.Text = "by: Ameksur"
byAmeksur.TextColor3 = Color3.fromRGB(255, 255, 255)
byAmeksur.TextScaled = true
byAmeksur.TextSize = 15.000
byAmeksur.TextTransparency = 0.300
byAmeksur.TextWrapped = true

UICorner_4.CornerRadius = UDim.new(0, 5)
UICorner_4.Parent = byAmeksur

UITextSizeConstraint_2.Parent = byAmeksur
UITextSizeConstraint_2.MaxTextSize = 15

UIAspectRatioConstraint_2.Parent = byAmeksur
UIAspectRatioConstraint_2.AspectRatio = 7.742

ScrollingFrame.Parent = Functions
ScrollingFrame.Active = true
ScrollingFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ScrollingFrame.BackgroundTransparency = 1.000
ScrollingFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
ScrollingFrame.BorderSizePixel = 0
ScrollingFrame.Position = UDim2.new(-0.00555555569, 0, 0, 0)
ScrollingFrame.Size = UDim2.new(1, 0, 0.86500001, 0)
ScrollingFrame.ScrollBarThickness = 10

SpeedBost.Name = "SpeedBost"
SpeedBost.Parent = ScrollingFrame
SpeedBost.AnchorPoint = Vector2.new(0.5, 0.5)
SpeedBost.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
SpeedBost.BackgroundTransparency = 0.700
SpeedBost.BorderColor3 = Color3.fromRGB(0, 0, 0)
SpeedBost.BorderSizePixel = 0
SpeedBost.Position = UDim2.new(0.504000306, 0, 0.0820000172, 0)
SpeedBost.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
SpeedBost.Font = Enum.Font.FredokaOne
SpeedBost.Text = "Speed soon"
SpeedBost.TextColor3 = Color3.fromRGB(110, 210, 240)
SpeedBost.TextScaled = true
SpeedBost.TextSize = 25.000
SpeedBost.TextWrapped = true

UICorner_5.CornerRadius = UDim.new(0, 10)
UICorner_5.Parent = SpeedBost

UITextSizeConstraint_3.Parent = SpeedBost
UITextSizeConstraint_3.MaxTextSize = 25

UIAspectRatioConstraint_3.Parent = SpeedBost
UIAspectRatioConstraint_3.AspectRatio = 3.061

AutoHit.Name = "AutoHit"
AutoHit.Parent = ScrollingFrame
AutoHit.AnchorPoint = Vector2.new(0.5, 0.5)
AutoHit.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
AutoHit.BackgroundTransparency = 0.700
AutoHit.BorderColor3 = Color3.fromRGB(0, 0, 0)
AutoHit.BorderSizePixel = 0
AutoHit.Position = UDim2.new(0.504000306, 0, 0.218239814, 0)
AutoHit.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
AutoHit.Font = Enum.Font.FredokaOne
AutoHit.Text = "AutoHit"
AutoHit.TextColor3 = Color3.fromRGB(110, 210, 240)
AutoHit.TextScaled = true
AutoHit.TextSize = 25.000
AutoHit.TextWrapped = true

UICorner_6.CornerRadius = UDim.new(0, 10)
UICorner_6.Parent = AutoHit

UITextSizeConstraint_4.Parent = AutoHit
UITextSizeConstraint_4.MaxTextSize = 25

UIAspectRatioConstraint_4.Parent = AutoHit
UIAspectRatioConstraint_4.AspectRatio = 3.061

DoubleJump.Name = "DoubleJump"
DoubleJump.Parent = ScrollingFrame
DoubleJump.AnchorPoint = Vector2.new(0.5, 0.5)
DoubleJump.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
DoubleJump.BackgroundTransparency = 0.700
DoubleJump.BorderColor3 = Color3.fromRGB(0, 0, 0)
DoubleJump.BorderSizePixel = 0
DoubleJump.Position = UDim2.new(0.504000306, 0, 0.354479581, 0)
DoubleJump.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
DoubleJump.Font = Enum.Font.FredokaOne
DoubleJump.Text = "DoubleJump"
DoubleJump.TextColor3 = Color3.fromRGB(110, 210, 240)
DoubleJump.TextScaled = true
DoubleJump.TextSize = 25.000
DoubleJump.TextWrapped = true

UICorner_7.CornerRadius = UDim.new(0, 10)
UICorner_7.Parent = DoubleJump

UITextSizeConstraint_5.Parent = DoubleJump
UITextSizeConstraint_5.MaxTextSize = 25

UIAspectRatioConstraint_5.Parent = DoubleJump
UIAspectRatioConstraint_5.AspectRatio = 3.061

ESPplayers.Name = "ESPplayers"
ESPplayers.Parent = ScrollingFrame
ESPplayers.AnchorPoint = Vector2.new(0.5, 0.5)
ESPplayers.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ESPplayers.BackgroundTransparency = 0.700
ESPplayers.BorderColor3 = Color3.fromRGB(0, 0, 0)
ESPplayers.BorderSizePixel = 0
ESPplayers.Position = UDim2.new(0.504000008, 0, 0.49000001, 0)
ESPplayers.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
ESPplayers.Font = Enum.Font.FredokaOne
ESPplayers.Text = "ESPplayers"
ESPplayers.TextColor3 = Color3.fromRGB(110, 210, 240)
ESPplayers.TextScaled = true
ESPplayers.TextSize = 25.000
ESPplayers.TextWrapped = true

UICorner_8.CornerRadius = UDim.new(0, 10)
UICorner_8.Parent = ESPplayers

UITextSizeConstraint_6.Parent = ESPplayers
UITextSizeConstraint_6.MaxTextSize = 25

UIAspectRatioConstraint_6.Parent = ESPplayers
UIAspectRatioConstraint_6.AspectRatio = 3.061

ESPinfo.Name = "ESPinfo"
ESPinfo.Parent = ScrollingFrame
ESPinfo.AnchorPoint = Vector2.new(0.5, 0.5)
ESPinfo.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ESPinfo.BackgroundTransparency = 0.700
ESPinfo.BorderColor3 = Color3.fromRGB(0, 0, 0)
ESPinfo.BorderSizePixel = 0
ESPinfo.Position = UDim2.new(0.504000008, 0, 0.625999987, 0)
ESPinfo.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
ESPinfo.Font = Enum.Font.FredokaOne
ESPinfo.Text = "ESPinfo"
ESPinfo.TextColor3 = Color3.fromRGB(110, 210, 240)
ESPinfo.TextScaled = true
ESPinfo.TextSize = 25.000
ESPinfo.TextWrapped = true

UICorner_9.CornerRadius = UDim.new(0, 10)
UICorner_9.Parent = ESPinfo

UITextSizeConstraint_7.Parent = ESPinfo
UITextSizeConstraint_7.MaxTextSize = 25

UIAspectRatioConstraint_7.Parent = ESPinfo
UIAspectRatioConstraint_7.AspectRatio = 3.061

XRay.Name = "XRay"
XRay.Parent = ScrollingFrame
XRay.AnchorPoint = Vector2.new(0.5, 0.5)
XRay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
XRay.BackgroundTransparency = 0.700
XRay.BorderColor3 = Color3.fromRGB(0, 0, 0)
XRay.BorderSizePixel = 0
XRay.Position = UDim2.new(0.504000008, 0, 0.762000024, 0)
XRay.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
XRay.Font = Enum.Font.FredokaOne
XRay.Text = "XRay"
XRay.TextColor3 = Color3.fromRGB(110, 210, 240)
XRay.TextScaled = true
XRay.TextSize = 25.000
XRay.TextWrapped = true

UICorner_10.CornerRadius = UDim.new(0, 10)
UICorner_10.Parent = XRay

UITextSizeConstraint_8.Parent = XRay
UITextSizeConstraint_8.MaxTextSize = 25

UIAspectRatioConstraint_8.Parent = XRay
UIAspectRatioConstraint_8.AspectRatio = 3.061

AntiRagdoll.Name = "AntiRagdoll"
AntiRagdoll.Parent = ScrollingFrame
AntiRagdoll.AnchorPoint = Vector2.new(0.5, 0.5)
AntiRagdoll.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
AntiRagdoll.BackgroundTransparency = 0.700
AntiRagdoll.BorderColor3 = Color3.fromRGB(0, 0, 0)
AntiRagdoll.BorderSizePixel = 0
AntiRagdoll.Position = UDim2.new(0.504000008, 0, 0.898000002, 0)
AntiRagdoll.Size = UDim2.new(0.889999986, 0, 0.115000002, 0)
AntiRagdoll.Font = Enum.Font.FredokaOne
AntiRagdoll.Text = "AntiRagdoll"
AntiRagdoll.TextColor3 = Color3.fromRGB(110, 210, 240)
AntiRagdoll.TextScaled = true
AntiRagdoll.TextSize = 25.000
AntiRagdoll.TextWrapped = true

UICorner_11.CornerRadius = UDim.new(0, 10)
UICorner_11.Parent = AntiRagdoll

UITextSizeConstraint_9.Parent = AntiRagdoll
UITextSizeConstraint_9.MaxTextSize = 25

UIAspectRatioConstraint_9.Parent = AntiRagdoll
UIAspectRatioConstraint_9.AspectRatio = 3.061

UIAspectRatioConstraint_10.Parent = ScrollingFrame
UIAspectRatioConstraint_10.AspectRatio = 0.915

UIAspectRatioConstraint_11.Parent = Functions
UIAspectRatioConstraint_11.AspectRatio = 0.791

UIAspectRatioConstraint_12.Parent = Warp
UIAspectRatioConstraint_12.AspectRatio = 0.622

UIAspectRatioConstraint_13.Parent = Gui
UIAspectRatioConstraint_13.AspectRatio = 0.646

Button.Name = "Button"
Button.Parent = ultimatePVP
Button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Button.BorderColor3 = Color3.fromRGB(0, 0, 0)
Button.BorderSizePixel = 0
Button.Position = UDim2.new(0.0250000004, 0, 0.0500000007, 0)
Button.Size = UDim2.new(0.0500000007, 0, 0.101999998, 0)

UICorner_12.CornerRadius = UDim.new(0, 15)
UICorner_12.Parent = Button

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(220, 220, 220)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(40, 40, 40))}
UIGradient_2.Offset = Vector2.new(0, 0.300000012)
UIGradient_2.Rotation = 90
UIGradient_2.Parent = Button

GuiMenu.Name = "GuiMenu"
GuiMenu.Parent = Button
GuiMenu.AnchorPoint = Vector2.new(0.5, 0.5)
GuiMenu.BackgroundColor3 = Color3.fromRGB(160, 160, 160)
GuiMenu.BackgroundTransparency = 0.700
GuiMenu.BorderColor3 = Color3.fromRGB(0, 0, 0)
GuiMenu.BorderSizePixel = 0
GuiMenu.Position = UDim2.new(0.5, 0, 0.5, 0)
GuiMenu.Size = UDim2.new(0.769999981, 0, 0.769999981, 0)
GuiMenu.Font = Enum.Font.FredokaOne
GuiMenu.Text = "Menu"
GuiMenu.TextColor3 = Color3.fromRGB(110, 210, 240)
GuiMenu.TextScaled = true
GuiMenu.TextSize = 16.000
GuiMenu.TextWrapped = true

UICorner_13.CornerRadius = UDim.new(0, 10)
UICorner_13.Parent = GuiMenu

UITextSizeConstraint_10.Parent = GuiMenu
UITextSizeConstraint_10.MaxTextSize = 16

UIAspectRatioConstraint_14.Parent = GuiMenu
UIAspectRatioConstraint_14.AspectRatio = 0.976

UIAspectRatioConstraint_15.Parent = Button
UIAspectRatioConstraint_15.AspectRatio = 0.976

info.Name = "info"
info.Parent = ultimatePVP
info.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
info.BorderColor3 = Color3.fromRGB(0, 0, 0)
info.BorderSizePixel = 0
info.Position = UDim2.new(0.375, 0, 0, 0)
info.Size = UDim2.new(0.247500002, 0, 0.101999998, 0)
info.Visible = false

UICorner_14.CornerRadius = UDim.new(0, 15)
UICorner_14.Parent = info

UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(220, 220, 220)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(40, 40, 40))}
UIGradient_3.Offset = Vector2.new(0, 0.300000012)
UIGradient_3.Rotation = 90
UIGradient_3.Parent = info

Warp_2.Name = "Warp"
Warp_2.Parent = info
Warp_2.AnchorPoint = Vector2.new(0.5, 0.5)
Warp_2.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
Warp_2.BackgroundTransparency = 0.850
Warp_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Warp_2.BorderSizePixel = 0
Warp_2.Position = UDim2.new(0.5, 0, 0.5, 0)
Warp_2.Size = UDim2.new(0.952000022, 0, 0.769999981, 0)

UICorner_15.CornerRadius = UDim.new(0, 10)
UICorner_15.Parent = Warp_2

name_2.Name = "name"
name_2.Parent = Warp_2
name_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
name_2.BackgroundTransparency = 0.700
name_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
name_2.BorderSizePixel = 0
name_2.Position = UDim2.new(0.0209689811, 0, 0.12939395, 0)
name_2.Size = UDim2.new(0.691976368, 0, 0.733232439, 0)
name_2.Font = Enum.Font.FredokaOne
name_2.Text = "null"
name_2.TextColor3 = Color3.fromRGB(110, 210, 240)
name_2.TextScaled = true
name_2.TextSize = 30.000
name_2.TextWrapped = true

UICorner_16.CornerRadius = UDim.new(0, 10)
UICorner_16.Parent = name_2

UITextSizeConstraint_11.Parent = name_2
UITextSizeConstraint_11.MaxTextSize = 30

UIAspectRatioConstraint_16.Parent = name_2
UIAspectRatioConstraint_16.AspectRatio = 5.636

Income.Name = "Income"
Income.Parent = Warp_2
Income.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Income.BackgroundTransparency = 0.700
Income.BorderColor3 = Color3.fromRGB(0, 0, 0)
Income.BorderSizePixel = 0
Income.Position = UDim2.new(0.733914375, 0, 0.12939395, 0)
Income.Size = UDim2.new(0.244638115, 0, 0.733232439, 0)
Income.Font = Enum.Font.FredokaOne
Income.Text = "null"
Income.TextColor3 = Color3.fromRGB(110, 210, 240)
Income.TextScaled = true
Income.TextSize = 30.000
Income.TextWrapped = true

UICorner_17.CornerRadius = UDim.new(0, 10)
UICorner_17.Parent = Income

UITextSizeConstraint_12.Parent = Income
UITextSizeConstraint_12.MaxTextSize = 30

UIAspectRatioConstraint_17.Parent = Income
UIAspectRatioConstraint_17.AspectRatio = 1.992

UIAspectRatioConstraint_18.Parent = Warp_2
UIAspectRatioConstraint_18.AspectRatio = 5.972

UIAspectRatioConstraint_19.Parent = info
UIAspectRatioConstraint_19.AspectRatio = 4.830

-- Scripts:

local function DPEXXB_fake_script() -- ultimatePVP.Gradient 
	local script = Instance.new('LocalScript', ultimatePVP)

	local Players = game:GetService("Players")
	local player = Players.LocalPlayer
	
	-- ИЗМЕНЕНО: Получаем GUI из CoreGui вместо PlayerGui
	local ultimatePVP = game:GetService("CoreGui"):WaitForChild("ultimatePVP")
	
	local color1 = Color3.fromRGB(110, 210, 240)
	local color2 = Color3.fromRGB(95, 120, 240)
	local speed = 1.5
	local timeOffset = 0
	
	local excludedPaths = {
		{"Gui", "Warp", "Functions", "by: Ameksur"}
	}
	
	local function findObjectByPath(parent, pathParts, index)
		if index > #pathParts then
			return parent
		end
	
		local childName = pathParts[index]
		local child = parent:FindFirstChild(childName)
	
		if child then
			return findObjectByPath(child, pathParts, index + 1)
		end
	
		return nil
	end
	
	local excludedObjects = {}
	for _, path in ipairs(excludedPaths) do
		local obj = findObjectByPath(ultimatePVP, path, 1)
		if obj then
			table.insert(excludedObjects, obj)
		end
	end
	
	local isExcluded = {}
	for _, obj in ipairs(excludedObjects) do
		isExcluded[obj] = true
	end
	
	local textObjects = {}
	
	local function collectTextObjects(parent)
		for _, child in ipairs(parent:GetChildren()) do
			if isExcluded[child] then
				continue
			end
	
			if child:IsA("TextButton") or child:IsA("TextLabel") then
				table.insert(textObjects, child)
			end
	
			if #child:GetChildren() > 0 then
				collectTextObjects(child)
			end
		end
	end
	
	collectTextObjects(ultimatePVP)
	
	local function updateGradient()
		timeOffset += task.wait()
		local t = (math.sin(timeOffset * speed) + 1) / 2
		local currentColor = color1:Lerp(color2, t)
	
		for _, textObject in ipairs(textObjects) do
			if textObject and textObject.Parent then
				textObject.TextColor3 = currentColor
			end
		end
	end
	
	while true do
		updateGradient()
	end
end
coroutine.wrap(DPEXXB_fake_script)()
local function ZWGMKD_fake_script() -- Gui.drag 
	local script = Instance.new('LocalScript', Gui)

	local frame = script.Parent
	local dragToggle = false
	local dragSpeed = 1
	local dragStart = Vector2.new(0, 0)
	local frameStart = Vector2.new(0, 0)
	
	local function updateInput(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			frameStart.X.Scale, 
			frameStart.X.Offset + (delta.X * dragSpeed),
			frameStart.Y.Scale, 
			frameStart.Y.Offset + (delta.Y * dragSpeed)
		)
	end
	
	frame.InputBegan:Connect(function(input)
		-- Добавляем поддержку тача для мобильных устройств
		if input.UserInputType == Enum.UserInputType.MouseButton1 
			or input.UserInputType == Enum.UserInputType.Touch then
	
			dragToggle = true
			dragStart = input.Position
			frameStart = frame.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)
	
	frame.InputChanged:Connect(function(input)
		-- Обрабатываем движение мыши И тач-движение
		if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch) then
			updateInput(input)
		end
	end)
	
	local UserInputService = game:GetService("UserInputService")
	
	UserInputService.InputChanged:Connect(function(input)
		if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch) then
			updateInput(input)
		end
	end)
end
coroutine.wrap(ZWGMKD_fake_script)()
local function LOUHY_fake_script() -- SpeedBost.FunctionSpeedBost 
	local script = Instance.new('LocalScript', SpeedBost)

	
end
coroutine.wrap(LOUHY_fake_script)()
local function DUGNLWO_fake_script() -- AutoHit.FunctionAutoHit 
	local script = Instance.new('LocalScript', AutoHit)

	local button = script.Parent
	local player = game.Players.LocalPlayer
	local runService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	
	local ZONE_OFFSET = Vector3.new(0, 0, -1.5)
	local ZONE_SIZE = Vector3.new(5, 6, 4)
	local HIT_INTERVAL = 1.5
	
	local active = false
	local hitboxZone = nil
	local connection = nil
	local lastHitTime = 0
	
	local validTools = {
		["Allen Slap"] = true,
		["Blackhole Slap"] = true,
		["Bloodmoon Slap"] = true,
		["Candy Slap"] = true,
		["Cursed Slap"] = true,
		["Dark Matter Slap"] = true,
		["Dev Slap"] = true,
		["Diamond Slap"] = true,
		["Emerald Slap"] = true,
		["Flame Slap"] = true,
		["Galaxy Slap"] = true,
		["Glitched Slap"] = true,
		["Gold Slap"] = true,
		["Iron Slap"] = true,
		["Lava Slap"] = true,
		["Nuclear Slap"] = true,
		["Radioactive Slap"] = true,
		["Rainbow Slap"] = true,
		["Ruby Slap"] = true,
		["Slap"] = true,
		["Splatter Slap"] = true,
		["Yin Yang Slap"] = true,
		["Bat"] = true
	}
	
	function hasValidTool(character)
		if not character then 
			return false 
		end
	
		local tool = character:FindFirstChildOfClass("Tool")
	
		if tool and validTools[tool.Name] then
			return tool
		end
	
		return false
	end
	
	function createHitboxZone(character)
		if not character then 
			return nil 
		end
		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then 
			return nil 
		end
	
		if hitboxZone then
			hitboxZone:Destroy()
			hitboxZone = nil
		end
	
		local part = Instance.new("Part")
		part.Name = "AutoHitZone"
		part.Size = ZONE_SIZE
		part.Transparency = 1
		part.CanCollide = false
		part.Anchored = false
		part.Massless = true
	
		local weld = Instance.new("Weld")
		weld.Part0 = hrp
		weld.Part1 = part
		weld.C0 = CFrame.new(ZONE_OFFSET)
	
		part.Parent = character
		weld.Parent = part
	
		return part
	end
	
	function findTargets()
		local character = player.Character
		if not character then 
			return {} 
		end
	
		if not hitboxZone or hitboxZone.Parent ~= character then
			hitboxZone = createHitboxZone(character)
			if not hitboxZone then 
				return {}
			end
		end
	
		local targets = {}
		local partsInZone = workspace:GetPartsInPart(hitboxZone)
	
		for _, part in ipairs(partsInZone) do
			if part.Name == "HumanoidRootPart" and part.Parent ~= character then
				local targetCharacter = part.Parent
				local targetPlayer = game.Players:GetPlayerFromCharacter(targetCharacter)
	
				if targetPlayer and targetPlayer ~= player and targetCharacter:FindFirstChildOfClass("Humanoid") then
					table.insert(targets, {
						player = targetPlayer,
						character = targetCharacter,
						hrp = part
					})
				end
			end
		end
	
		return targets
	end
	
	function checkHitbox()
		if not active then return end
	
		local character = player.Character
		if not character then 
			return 
		end
	
		local tool = hasValidTool(character)
		if not tool then 
			return 
		end
	
		local targets = findTargets()
		local currentTime = tick()
	
		if #targets > 0 and currentTime - lastHitTime >= HIT_INTERVAL then
			lastHitTime = currentTime
	
			if tool:IsA("Tool") and tool:FindFirstChild("Handle") then
				tool:Activate()
	
				pcall(function()
					for _, child in ipairs(tool:GetDescendants()) do
						if child:IsA("ClickDetector") then
							fireclickdetector(child)
							break
						end
					end
				end)
	
				pcall(function()
					local remotes = tool:GetChildren()
					for _, remote in ipairs(remotes) do
						if remote:IsA("RemoteEvent") then
							remote:FireServer()
						end
					end
				end)
			end
		end
	end
	
	function cleanupZone()
		if hitboxZone then
			hitboxZone:Destroy()
			hitboxZone = nil
		end
		if connection then
			connection:Disconnect()
			connection = nil
		end
	
		lastHitTime = 0
	end
	
	local function toggleActive()
		active = not active
	
		if active then
			button.BackgroundTransparency = 0.4
	
			if player.Character then
				hitboxZone = createHitboxZone(player.Character)
			end
	
			connection = runService.Heartbeat:Connect(function()
				pcall(function()
					checkHitbox()
				end)
			end)
	
			player.CharacterAdded:Connect(function()
				if active then
					cleanupZone()
					task.wait(1)
					if player.Character then
						hitboxZone = createHitboxZone(player.Character)
					end
				end
			end)
		else
			button.BackgroundTransparency = 0.7
			cleanupZone()
		end
	end
	
	if UserInputService.TouchEnabled then
		button.TouchTap:Connect(toggleActive)
		button.TouchLongPress:Connect(toggleActive)
	end
	
	button.MouseButton1Click:Connect(toggleActive)
	
	script.Destroying:Connect(cleanupZone)
	
	button.BackgroundTransparency = 0.7
end
coroutine.wrap(DUGNLWO_fake_script)()
local function OHUREEL_fake_script() -- DoubleJump.FunctionDoubleJump 
	local script = Instance.new('LocalScript', DoubleJump)

	local button = script.Parent
	local UserInputService = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	
	local enabled = false
	local hasDoubleJump = false
	local canDoubleJump = false
	local connections = {}
	local jumpPower = 50
	
	local isMobile = UserInputService.TouchEnabled
	
	local touchJumpPressed = false
	local touchJumpConnection = nil
	
	local function getJumpPower(character)
		local humanoid = character and character:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.JumpPower > 0 then
			return humanoid.JumpPower
		end
		return jumpPower
	end
	
	local function isGrounded(character)
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return false end
	
		if humanoid:GetState() == Enum.HumanoidStateType.Landed then
			return true
		end
	
		if humanoid.FloorMaterial ~= Enum.Material.Air then
			return true
		end
	
		return false
	end
	
	local function performDoubleJump(character)
		if not character or not canDoubleJump or hasDoubleJump then return end
	
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		local rootPart = character:FindFirstChild("HumanoidRootPart")
	
		if not humanoid or not rootPart then return end
	
		local currentVelocity = rootPart.Velocity
		rootPart.Velocity = Vector3.new(currentVelocity.X, 0, currentVelocity.Z)
	
		task.wait(0.02)
	
		local jumpForce = getJumpPower(character)
		rootPart.Velocity = Vector3.new(
			currentVelocity.X,
			jumpForce,
			currentVelocity.Z
		)
	
		hasDoubleJump = true
		canDoubleJump = false
	
		task.spawn(function()
			local particles = Instance.new("ParticleEmitter")
			particles.Size = NumberSequence.new(0.5)
			particles.Transparency = NumberSequence.new(0.5)
			particles.Lifetime = NumberRange.new(0.3)
			particles.Rate = 10
			particles.Speed = NumberRange.new(2)
			particles.Color = ColorSequence.new(Color3.new(1, 1, 1))
			particles.Parent = rootPart
	
			task.wait(0.2)
			particles:Destroy()
		end)
	
		return true
	end
	
	local function setupMobileJumpInput()
		if not isMobile then return end
	
		touchJumpConnection = UserInputService.TouchTap:Connect(function()
			if not enabled then return end
	
			if isMobile then
				local character = localPlayer.Character
				if not character then return end
	
				if isGrounded(character) then
					hasDoubleJump = false
					canDoubleJump = false
				elseif canDoubleJump and not hasDoubleJump then
					performDoubleJump(character)
				end
			end
		end)
	
		if touchJumpConnection then
			table.insert(connections, touchJumpConnection)
		end
	
		local longPressConnection = UserInputService.TouchLongPress:Connect(function()
			if not enabled then return end
	
			if isMobile then
				local character = localPlayer.Character
				if not character then return end
	
				if isGrounded(character) then
					hasDoubleJump = false
					canDoubleJump = false
				elseif canDoubleJump and not hasDoubleJump then
					performDoubleJump(character)
				end
			end
		end)
	
		table.insert(connections, longPressConnection)
	end
	
	local function setupDoubleJump()
		if not localPlayer.Character then
			localPlayer.CharacterAdded:Wait()
		end
	
		local character = localPlayer.Character
		local humanoid = character:FindFirstChildOfClass("Humanoid")
	
		if not humanoid then return end
	
		table.insert(connections, humanoid.StateChanged:Connect(function(_, newState)
			if newState == Enum.HumanoidStateType.Landed then
				hasDoubleJump = false
				canDoubleJump = false
			elseif newState == Enum.HumanoidStateType.Freefall then
				task.wait(0.05)
				canDoubleJump = true
			end
		end))
	
		if isMobile then
			setupMobileJumpInput()
		else
			local jumpConnection
			jumpConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
				if not enabled or gameProcessed then return end
	
				if input.KeyCode == Enum.KeyCode.Space then
					if isGrounded(character) then
						hasDoubleJump = false
						canDoubleJump = false
					elseif canDoubleJump and not hasDoubleJump then
						performDoubleJump(character)
					end
				end
			end)
	
			table.insert(connections, jumpConnection)
		end
	
		table.insert(connections, humanoid.Jumping:Connect(function(isJumping)
			if isJumping then
				canDoubleJump = true
			end
		end))
	end
	
	local function cleanupConnections()
		if touchJumpConnection then
			touchJumpConnection:Disconnect()
			touchJumpConnection = nil
		end
	
		for _, connection in ipairs(connections) do
			if connection then
				connection:Disconnect()
			end
		end
		connections = {}
		hasDoubleJump = false
		canDoubleJump = false
	end
	
	if isMobile then
		button.TouchTap:Connect(function()
			enabled = not enabled
	
			if enabled then
				button.BackgroundTransparency = 0.4
				cleanupConnections()
				setupDoubleJump()
	
				local charConnection
				charConnection = localPlayer.CharacterAdded:Connect(function(character)
					cleanupConnections()
					if enabled then
						task.wait(0.3)
						setupDoubleJump()
					end
				end)
	
				table.insert(connections, charConnection)
	
			else
				button.BackgroundTransparency = 0.7
				cleanupConnections()
			end
		end)
	end
	
	button.MouseButton1Click:Connect(function()
		enabled = not enabled
	
		if enabled then
			button.BackgroundTransparency = 0.4
			cleanupConnections()
			setupDoubleJump()
	
			local charConnection
			charConnection = localPlayer.CharacterAdded:Connect(function(character)
				cleanupConnections()
				if enabled then
					task.wait(0.3)
					setupDoubleJump()
				end
			end)
	
			table.insert(connections, charConnection)
	
		else
			button.BackgroundTransparency = 0.7
			cleanupConnections()
		end
	end)
	
	script.Destroying:Connect(cleanupConnections)
	
	button.BackgroundTransparency = 0.7
end
coroutine.wrap(OHUREEL_fake_script)()
local function HUVWMYQ_fake_script() -- ESPplayers.FunctionESPplayers 
	local script = Instance.new('LocalScript', ESPplayers)

	local Players = game:GetService("Players")
	local button = script.Parent
	
	local enabled = false
	local highlights = {}
	local originalTransparencies = {}
	
	local function createESP(player)
		if not player or not player.Character then return end
	
		local character = player.Character
		local rootPart = character:WaitForChild("HumanoidRootPart", 2)
		if not rootPart then return end
	
		if highlights[player] then
			pcall(function() 
				highlights[player]:Destroy() 
			end)
			highlights[player] = nil
		end
	
		if not originalTransparencies[player] then
			originalTransparencies[player] = rootPart.Transparency
		end
	
		rootPart.Transparency = 0
	
		local highlight = Instance.new("Highlight")
		highlight.Name = player == Players.LocalPlayer and "PESP" or "ESP"
		highlight.FillColor = player == Players.LocalPlayer 
			and Color3.fromRGB(0, 255, 0) 
			or Color3.fromRGB(255, 0, 0)
		highlight.FillTransparency = 0.5
		highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Adornee = character
		highlight.Parent = character
	
		highlights[player] = highlight
	end
	
	local function removeESP(player)
		if not player then return end
	
		if highlights[player] then
			pcall(function() 
				highlights[player]:Destroy() 
			end)
			highlights[player] = nil
		end
	
		if player.Character then
			local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
			if rootPart and originalTransparencies[player] then
				rootPart.Transparency = originalTransparencies[player]
			end
		end
	
		originalTransparencies[player] = nil
	end
	
	button.MouseButton1Click:Connect(function()
		enabled = not enabled
	
		if enabled then
			button.BackgroundTransparency = 0.4
	
			for _, player in ipairs(Players:GetPlayers()) do
				if player.Character then
					createESP(player)
				else
					player.CharacterAdded:Once(function(character)
						if enabled then
							task.wait(0.3)
							createESP(player)
						end
					end)
				end
			end
	
			Players.PlayerAdded:Connect(function(player)
				if enabled then
					player.CharacterAdded:Once(function(character)
						if enabled then
							task.wait(0.3)
							createESP(player)
						end
					end)
	
					if player.Character then
						createESP(player)
					end
				end
			end)
	
			Players.PlayerRemoving:Connect(function(player)
				removeESP(player)
			end)
	
		else
			button.BackgroundTransparency = 0.7
	
			for _, player in ipairs(Players:GetPlayers()) do
				removeESP(player)
			end
	
			highlights = {}
			originalTransparencies = {}
		end
	end)
	
	Players.PlayerRemoving:Connect(function(player)
		removeESP(player)
	end)
	
	local function setupCharacterListener(player)
		player.CharacterAdded:Connect(function(character)
			task.wait(0.3)
			if enabled then
				removeESP(player)
				createESP(player)
			end
		end)
	end
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupCharacterListener(player)
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupCharacterListener(player)
	end)
	
	button.BackgroundTransparency = 0.7
	enabled = false
end
coroutine.wrap(HUVWMYQ_fake_script)()
local function AODYVV_fake_script() -- ESPinfo.FunctionESPinfo 
	local script = Instance.new('LocalScript', ESPinfo)

	-- LocalScript для кнопки ESPinfo
	-- DeepHack - исправленный таймер
	
	local button = script.Parent
	local espEnabled = false
	local connections = {}
	local createdGUIs = {}
	local brainrotData = {
		currentBest = nil,
		currentValue = 0,
		brainrotGUI = nil
	}
	local infoFrame = nil
	
	-- Переменные для Attachments и Beam
	local playerAttachment = nil
	local infoBeam = nil
	
	-- Функция для получения фрейма info
	local function getInfoFrame()
		if infoFrame and infoFrame.Parent then
			return infoFrame
		end
	
		local ultimatePVP = button.Parent
		while ultimatePVP and ultimatePVP.Name ~= "ultimatePVP" do
			ultimatePVP = ultimatePVP.Parent
		end
	
		if not ultimatePVP then return nil end
	
		infoFrame = ultimatePVP:FindFirstChild("info")
		return infoFrame
	end
	
	-- Показать/скрыть фрейм info
	local function setInfoFrameVisibility(visible)
		local info = getInfoFrame()
		if info then
			info.Visible = visible
		end
	end
	
	-- Создание Attachment на игроке
	local function createPlayerAttachment()
		if playerAttachment then
			playerAttachment:Destroy()
			playerAttachment = nil
		end
	
		local player = game.Players.LocalPlayer
		if not player then return end
	
		local character = player.Character
		if not character then return end
	
		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then return end
	
		playerAttachment = Instance.new("Attachment")
		playerAttachment.Name = "PlayerPositionPoint"
		playerAttachment.Parent = humanoidRootPart
	
		return playerAttachment
	end
	
	-- Создание Beam между игроком и BrainrotInfo
	local function createInfoBeam(infoAttachment)
		if infoBeam then
			infoBeam:Destroy()
			infoBeam = nil
		end
	
		if not playerAttachment or not infoAttachment then return end
	
		infoBeam = Instance.new("Beam")
		infoBeam.Name = "InfoWay"
		infoBeam.Color = ColorSequence.new(Color3.fromRGB(255, 230, 0))
		infoBeam.Attachment0 = playerAttachment
		infoBeam.Attachment1 = infoAttachment
		infoBeam.FaceCamera = true
		infoBeam.Parent = workspace
	
		return infoBeam
	end
	
	-- Удаление Attachments и Beam
	local function removeAttachmentsAndBeam()
		if playerAttachment then
			playerAttachment:Destroy()
			playerAttachment = nil
		end
	
		if infoBeam then
			infoBeam:Destroy()
			infoBeam = nil
		end
	end
	
	local function createESP(model)
		local spawnFolder = model:FindFirstChild("Spawn")
		if not spawnFolder then return nil end
	
		local espGUI = Instance.new("BillboardGui")
		espGUI.Name = "ESPtimeGUI"
		espGUI.AlwaysOnTop = true
		espGUI.Size = UDim2.new(0, 250, 0, 100)
		espGUI.Adornee = spawnFolder
		espGUI.Enabled = false
		espGUI.Parent = spawnFolder
	
		local timeLabel = Instance.new("TextLabel")
		timeLabel.Name = "Time"
		timeLabel.BackgroundTransparency = 1
		timeLabel.Size = UDim2.new(0, 250, 0, 100)
		timeLabel.FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json")
		timeLabel.Text = "Time"
		timeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		timeLabel.TextSize = 50
		timeLabel.Visible = false
		timeLabel.Parent = espGUI
	
		local uiStroke = Instance.new("UIStroke")
		uiStroke.Name = "UIStroke"
		uiStroke.Thickness = 3.5
		uiStroke.Enabled = false
		uiStroke.Parent = timeLabel
	
		return {espGUI = espGUI, timeLabel = timeLabel}
	end
	
	local function hasOurElements(model)
		local spawnFolder = model:FindFirstChild("Spawn")
		if not spawnFolder then return false end
	
		local espGUI = spawnFolder:FindFirstChild("ESPtimeGUI")
		if not espGUI then return false end
	
		local timeLabel = espGUI:FindFirstChild("Time")
		if not timeLabel then return false end
	
		local uiStroke = timeLabel:FindFirstChild("UIStroke")
		if not uiStroke then return false end
	
		return true
	end
	
	local function updateTimeForModel(model)
		if not createdGUIs[model] then return end
	
		local timeLabel = createdGUIs[model].timeLabel
		if not timeLabel or not timeLabel.Parent then return end
	
		for _, child in ipairs(model:GetChildren()) do
			if child.Name:find("Purchases") then
				local plotBlock = child:FindFirstChild("PlotBlock")
				if plotBlock then
					local main = plotBlock:FindFirstChild("Main")
					if main then
						local billboardGui = main:FindFirstChild("BillboardGui")
						if billboardGui then
							local remainingTime = billboardGui:FindFirstChild("RemainingTime")
							if remainingTime then
								timeLabel.Text = remainingTime.Visible and remainingTime.Text or "Unlocked"
								return
							end
						end
					end
				end
			end
		end
	end
	
	local function checkAllModels()
		if not espEnabled then return end
	
		local plots = workspace:FindFirstChild("Plots")
		if not plots then return end
	
		for _, model in ipairs(plots:GetChildren()) do
			if not createdGUIs[model] or not hasOurElements(model) then
				local guiData = createESP(model)
				if guiData then
					createdGUIs[model] = guiData
	
					-- Устанавливаем видимость если функция активна
					if espEnabled then
						guiData.espGUI.Enabled = true
						if guiData.timeLabel then
							guiData.timeLabel.Visible = true
							local uiStroke = guiData.timeLabel:FindFirstChild("UIStroke")
							if uiStroke then
								uiStroke.Enabled = true
							end
						end
					end
				end
			end
		end
	end
	
	local function convertGenerationToNumber(genText)
		if not genText then return 0 end
	
		local numText = genText:match("%$([%d%.]+)")
		if not numText then return 0 end
	
		local number = tonumber(numText) or 0
	
		if genText:find("B/s") then
			return number * 1000000000
		elseif genText:find("M/s") then
			return number * 1000000
		elseif genText:find("K/s") then
			return number * 1000
		else
			return number
		end
	end
	
	local function findBestGeneration()
		local debris = workspace:FindFirstChild("Debris")
		if not debris then return nil, 0 end
	
		local bestTemplate = nil
		local bestValue = 0
		local displayName = ""
		local generationText = ""
	
		for _, template in ipairs(debris:GetDescendants()) do
			if template.Name == "FastOverheadTemplate" then
				local animalOverhead = template:FindFirstChild("AnimalOverhead")
				if animalOverhead then
					local generation = animalOverhead:FindFirstChild("Generation")
					if generation and generation:IsA("TextLabel") then
						local genValue = convertGenerationToNumber(generation.Text)
	
						if genValue > bestValue then
							bestValue = genValue
							bestTemplate = template
	
							local display = animalOverhead:FindFirstChild("DisplayName")
							if display and display:IsA("TextLabel") then
								displayName = display.Text
							else
								displayName = "Unknown"
							end
	
							generationText = generation.Text
						end
					end
				end
			end
		end
	
		return bestTemplate, bestValue, displayName, generationText
	end
	
	local function createBrainrotInfo(template, displayName, generationText)
		if brainrotData.brainrotGUI then
			brainrotData.brainrotGUI:Destroy()
			brainrotData.brainrotGUI = nil
		end
	
		local brainrotGUI = Instance.new("BillboardGui")
		brainrotGUI.Name = "BrainrotInfo"
		brainrotGUI.AlwaysOnTop = true
		brainrotGUI.Size = UDim2.new(10, 0, 4, 0)
		brainrotGUI.Adornee = template
		brainrotGUI.Enabled = espEnabled
		brainrotGUI.Parent = template
	
		-- Создаём Attachment в BrainrotInfo
		local infoAttachment = Instance.new("Attachment")
		infoAttachment.Name = "InfoPoint"
		infoAttachment.Parent = brainrotGUI
	
		-- Создаём Beam если функция активна
		if espEnabled and playerAttachment then
			createInfoBeam(infoAttachment)
		end
	
		local nameLabel = Instance.new("TextLabel")
		nameLabel.Name = "name"
		nameLabel.BackgroundTransparency = 1
		nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
		nameLabel.Position = UDim2.new(0, 0, 0, 0)
		nameLabel.FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json")
		nameLabel.Text = displayName
		nameLabel.TextColor3 = Color3.fromRGB(255, 230, 0)
		nameLabel.TextScaled = true
		nameLabel.TextSize = 15
		nameLabel.Visible = espEnabled
		nameLabel.Parent = brainrotGUI
	
		local nameStroke = Instance.new("UIStroke")
		nameStroke.Color = Color3.fromRGB(0, 0, 0)
		nameStroke.Thickness = 2
		nameStroke.Transparency = 0.3
		nameStroke.Enabled = espEnabled
		nameStroke.Parent = nameLabel
	
		local incomeLabel = Instance.new("TextLabel")
		incomeLabel.Name = "Income"
		incomeLabel.BackgroundTransparency = 1
		incomeLabel.Size = UDim2.new(1, 0, 0.5, 0)
		incomeLabel.Position = UDim2.new(0, 0, 0.5, 0)
		incomeLabel.FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json")
		incomeLabel.Text = generationText
		incomeLabel.TextColor3 = Color3.fromRGB(255, 230, 0)
		incomeLabel.TextScaled = true
		incomeLabel.TextSize = 15
		incomeLabel.Visible = espEnabled
		incomeLabel.Parent = brainrotGUI
	
		local incomeStroke = Instance.new("UIStroke")
		incomeStroke.Color = Color3.fromRGB(0, 0, 0)
		incomeStroke.Thickness = 2
		incomeStroke.Transparency = 0.3
		incomeStroke.Enabled = espEnabled
		incomeStroke.Parent = incomeLabel
	
		brainrotData.brainrotGUI = brainrotGUI
		brainrotData.currentBest = template
		brainrotData.currentValue = convertGenerationToNumber(generationText)
	
		return brainrotGUI
	end
	
	local function updateWarpGUI(displayName, generationText)
		local info = getInfoFrame()
		if not info then return end
	
		local warp = info:FindFirstChild("Warp")
		if not warp then return end
	
		local nameLabel = warp:FindFirstChild("name")
		local incomeLabel = warp:FindFirstChild("Income")
	
		if nameLabel and nameLabel:IsA("TextLabel") then
			nameLabel.Text = displayName
		end
	
		if incomeLabel and incomeLabel:IsA("TextLabel") then
			incomeLabel.Text = generationText
		end
	end
	
	local function checkBestGeneration()
		if not espEnabled then return end
	
		local bestTemplate, bestValue, displayName, generationText = findBestGeneration()
	
		if brainrotData.currentBest and not brainrotData.currentBest.Parent then
			if brainrotData.brainrotGUI then
				brainrotData.brainrotGUI:Destroy()
				brainrotData.brainrotGUI = nil
			end
			brainrotData.currentBest = nil
			brainrotData.currentValue = 0
		end
	
		if bestTemplate and bestValue > 0 then
			if not brainrotData.currentBest or bestValue > brainrotData.currentValue then
				updateWarpGUI(displayName, generationText)
				createBrainrotInfo(bestTemplate, displayName, generationText)
			end
		else
			if brainrotData.currentBest then
				if brainrotData.brainrotGUI then
					brainrotData.brainrotGUI:Destroy()
					brainrotData.brainrotGUI = nil
				end
				brainrotData.currentBest = nil
				brainrotData.currentValue = 0
			end
		end
	end
	
	local function enableESP()
		espEnabled = true
		button.BackgroundTransparency = 0.4
	
		-- Показать info фрейм
		setInfoFrameVisibility(true)
	
		-- Создать Attachment на игроке
		createPlayerAttachment()
	
		for _, conn in pairs(connections) do
			conn:Disconnect()
		end
		connections = {}
	
		-- Первоначальная проверка всех моделей
		checkAllModels()
	
		-- Обновление времени каждые 0.5 секунд
		local updateTimer = 0
		local updateConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
			updateTimer = updateTimer + deltaTime
	
			-- Обновляем текст времени каждые 0.5 секунд
			if updateTimer >= 0.5 then
				updateTimer = 0
				for model, _ in pairs(createdGUIs) do
					if model.Parent then
						updateTimeForModel(model)
					end
				end
			end
		end)
	
		table.insert(connections, updateConnection)
	
		-- Проверка наличия наших элементов в моделях каждые 0.5 секунд
		local checkTimer = 0
		local checkConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
			checkTimer = checkTimer + deltaTime
			if checkTimer >= 0.5 then
				checkTimer = 0
				checkAllModels()
			end
		end)
	
		table.insert(connections, checkConnection)
	
		-- Следим за новыми моделями в Plots
		local plots = workspace:WaitForChild("Plots")
		local newModelConnection = plots.ChildAdded:Connect(function(model)
			task.wait(0.2)
	
			if not createdGUIs[model] or not hasOurElements(model) then
				local guiData = createESP(model)
				if guiData then
					createdGUIs[model] = guiData
					if espEnabled then
						guiData.espGUI.Enabled = true
						if guiData.timeLabel then
							guiData.timeLabel.Visible = true
							local uiStroke = guiData.timeLabel:FindFirstChild("UIStroke")
							if uiStroke then
								uiStroke.Enabled = true
							end
						end
					end
				end
			end
		end)
	
		table.insert(connections, newModelConnection)
	
		-- Следим за удалением моделей
		local removedModelConnection = plots.ChildRemoved:Connect(function(model)
			if createdGUIs[model] and createdGUIs[model].espGUI then
				createdGUIs[model].espGUI:Destroy()
				createdGUIs[model] = nil
			end
		end)
	
		table.insert(connections, removedModelConnection)
	
		-- Проверка лучшего Generation каждые 0.5 секунд
		local generationTimer = 0
		local checkGenerationConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
			generationTimer = generationTimer + deltaTime
			if generationTimer >= 0.5 then
				generationTimer = 0
				checkBestGeneration()
			end
		end)
	
		table.insert(connections, checkGenerationConnection)
	
		-- Включить видимость ESP элементов
		for model, guiData in pairs(createdGUIs) do
			if guiData.espGUI then
				guiData.espGUI.Enabled = true
				if guiData.timeLabel then
					guiData.timeLabel.Visible = true
					local uiStroke = guiData.timeLabel:FindFirstChild("UIStroke")
					if uiStroke then
						uiStroke.Enabled = true
					end
				end
			end
		end
	
		-- Обновить BrainrotInfo видимость
		if brainrotData.brainrotGUI then
			brainrotData.brainrotGUI.Enabled = true
			local nameLabel = brainrotData.brainrotGUI:FindFirstChild("name")
			if nameLabel then
				nameLabel.Visible = true
			end
			local incomeLabel = brainrotData.brainrotGUI:FindFirstChild("Income")
			if incomeLabel then
				incomeLabel.Visible = true
			end
	
			-- Создать Beam если BrainrotInfo уже существует
			local infoAttachment = brainrotData.brainrotGUI:FindFirstChild("InfoPoint")
			if infoAttachment then
				createInfoBeam(infoAttachment)
			end
		end
	
		-- Первоначальная проверка лучшего Generation
		checkBestGeneration()
	end
	
	local function disableESP()
		espEnabled = false
		button.BackgroundTransparency = 0.7
	
		-- Скрыть info фрейм
		setInfoFrameVisibility(false)
	
		-- Удалить Attachments и Beam
		removeAttachmentsAndBeam()
	
		for _, conn in pairs(connections) do
			conn:Disconnect()
		end
		connections = {}
	
		-- Скрыть ESP элементы
		for model, guiData in pairs(createdGUIs) do
			if guiData.espGUI then
				guiData.espGUI.Enabled = false
				if guiData.timeLabel then
					guiData.timeLabel.Visible = false
					local uiStroke = guiData.timeLabel:FindFirstChild("UIStroke")
					if uiStroke then
						uiStroke.Enabled = false
					end
				end
			end
		end
	
		-- Скрыть BrainrotInfo
		if brainrotData.brainrotGUI then
			brainrotData.brainrotGUI.Enabled = false
			local nameLabel = brainrotData.brainrotGUI:FindFirstChild("name")
			if nameLabel then
				nameLabel.Visible = false
			end
			local incomeLabel = brainrotData.brainrotGUI:FindFirstChild("Income")
			if incomeLabel then
				incomeLabel.Visible = false
			end
		end
	end
	
	button.MouseButton1Click:Connect(function()
		if espEnabled then
			disableESP()
		else
			enableESP()
		end
	end)
	
	button.BackgroundTransparency = 0.7
	
	-- Изначально скрываем info фрейм
	task.wait(0.5)
	setInfoFrameVisibility(false)
	
	-- Слушатель для пересоздания Attachment при смерти/респавне игрока
	local player = game.Players.LocalPlayer
	player.CharacterAdded:Connect(function(character)
		if espEnabled then
			task.wait(1) -- Даём время на загрузку персонажа
			createPlayerAttachment()
	
			-- Пересоздаём Beam если есть BrainrotInfo
			if brainrotData.brainrotGUI then
				local infoAttachment = brainrotData.brainrotGUI:FindFirstChild("InfoPoint")
				if infoAttachment then
					createInfoBeam(infoAttachment)
				end
			end
		end
	end)
	
	script.Destroying:Connect(disableESP)
end
coroutine.wrap(AODYVV_fake_script)()
local function DTNBU_fake_script() -- XRay.FunctionXRay 
	local script = Instance.new('LocalScript', XRay)

	local button = script.Parent
	local xrayActive = false
	local trackedObjects = {}
	local rootConnections = {}
	local targetNames = {
		"Decorations",
		"Skin",
		"CashPad",
		"FriendPanel",
		"Model",
		"PlotSign"
	}
	
	local function processPart(part, applyXray)
		if not part or not part.Parent then return end
	
		local isPart = part:IsA("BasePart") or 
			part:IsA("MeshPart") or 
			part:IsA("UnionOperation") or
			part:IsA("TrussPart") or
			part:IsA("WedgePart") or
			part:IsA("CornerWedgePart") or
			part:IsA("Part")
	
		if not isPart then return end
	
		if applyXray then
			if not trackedObjects[part] then
				trackedObjects[part] = {
					original = part.Transparency,
					connection = part.AncestryChanged:Connect(function(child, parent)
						if not child or not child:IsDescendantOf(workspace) then
							if trackedObjects[child] then
								trackedObjects[child].connection:Disconnect()
								trackedObjects[child] = nil
							end
						end
					end)
				}
			end
	
			if part.Transparency < 0.5 then
				part.Transparency = 0.5
			end
		else
			if trackedObjects[part] then
				local originalTransparency = trackedObjects[part].original
	
				if trackedObjects[part].connection then
					trackedObjects[part].connection:Disconnect()
				end
	
				part.Transparency = originalTransparency
				trackedObjects[part] = nil
			end
		end
	end
	
	local function processDescendants(object, applyXray)
		if not object then return end
	
		processPart(object, applyXray)
	
		for _, descendant in ipairs(object:GetDescendants()) do
			processPart(descendant, applyXray)
		end
	end
	
	local function processPlot(plot, applyXray)
		if not plot then return end
	
		for _, targetName in ipairs(targetNames) do
			local target = plot:FindFirstChild(targetName)
			if target then
				processDescendants(target, applyXray)
			end
		end
	end
	
	local function processAllPlots(applyXray)
		local plots = workspace:FindFirstChild("Plots")
		if not plots then return end
	
		for _, plot in ipairs(plots:GetChildren()) do
			processPlot(plot, applyXray)
		end
	end
	
	local function setupPlotMonitoring(plot)
		if not plot then return end
	
		local plotConnections = {}
	
		for _, targetName in ipairs(targetNames) do
			local existingTarget = plot:FindFirstChild(targetName)
			if existingTarget then
				local conn = existingTarget.DescendantAdded:Connect(function(descendant)
					if xrayActive then
						task.wait(0.05)
						processPart(descendant, true)
					end
				end)
				table.insert(plotConnections, conn)
			end
	
			local conn = plot.ChildAdded:Connect(function(child)
				if child.Name == targetName then
					if xrayActive then
						processDescendants(child, true)
					end
	
					local descConn = child.DescendantAdded:Connect(function(descendant)
						if xrayActive then
							task.wait(0.05)
							processPart(descendant, true)
						end
					end)
					table.insert(plotConnections, descConn)
				end
			end)
			table.insert(plotConnections, conn)
		end
	
		local plotRemovedConn
		plotRemovedConn = plot.AncestryChanged:Connect(function(child, parent)
			if not child or not child:IsDescendantOf(workspace) then
				for part, data in pairs(trackedObjects) do
					if part:IsDescendantOf(plot) then
						if data.connection then
							data.connection:Disconnect()
						end
						trackedObjects[part] = nil
					end
				end
	
				for _, conn in ipairs(plotConnections) do
					conn:Disconnect()
				end
	
				if plotRemovedConn then
					plotRemovedConn:Disconnect()
				end
			end
		end)
		table.insert(plotConnections, plotRemovedConn)
	
		return plotConnections
	end
	
	local function setupGlobalMonitoring()
		local plots = workspace:FindFirstChild("Plots")
		if not plots then return end
	
		for _, conn in ipairs(rootConnections) do
			conn:Disconnect()
		end
		rootConnections = {}
	
		for _, plot in ipairs(plots:GetChildren()) do
			local plotConns = setupPlotMonitoring(plot)
			for _, conn in ipairs(plotConns) do
				table.insert(rootConnections, conn)
			end
		end
	
		local newPlotConn = plots.ChildAdded:Connect(function(child)
			task.wait(0.3)
	
			local plotConns = setupPlotMonitoring(child)
			for _, conn in ipairs(plotConns) do
				table.insert(rootConnections, conn)
			end
	
			if xrayActive then
				processPlot(child, true)
			end
		end)
		table.insert(rootConnections, newPlotConn)
	
		local plotsRemovedConn = plots.ChildRemoved:Connect(function(child)
			for part, data in pairs(trackedObjects) do
				if not part or not part.Parent then
					if data.connection then
						data.connection:Disconnect()
					end
					trackedObjects[part] = nil
				end
			end
		end)
		table.insert(rootConnections, plotsRemovedConn)
	end
	
	local function cleanupDeletedObjects()
		local toRemove = {}
	
		for part, data in pairs(trackedObjects) do
			if not part or not part.Parent or not part:IsDescendantOf(workspace) then
				table.insert(toRemove, part)
			end
		end
	
		for _, part in ipairs(toRemove) do
			if trackedObjects[part] and trackedObjects[part].connection then
				trackedObjects[part].connection:Disconnect()
			end
			trackedObjects[part] = nil
		end
	end
	
	button.MouseButton1Click:Connect(function()
		xrayActive = not xrayActive
	
		if xrayActive then
			button.BackgroundTransparency = 0.4
	
			cleanupDeletedObjects()
	
			setupGlobalMonitoring()
	
			processAllPlots(true)
	
		else
			button.BackgroundTransparency = 0.7
	
			processAllPlots(false)
	
			for _, conn in ipairs(rootConnections) do
				conn:Disconnect()
			end
			rootConnections = {}
		end
	end)
	
	task.wait(1)
	cleanupDeletedObjects()
	
	while true do
		task.wait(10)
		cleanupDeletedObjects()
	end
end
coroutine.wrap(DTNBU_fake_script)()
local function MDAEPYQ_fake_script() -- AntiRagdoll.FunctionAntiRagdoll 
	local script = Instance.new('LocalScript', AntiRagdoll)

	local button = script.Parent
	local enabled = false
	local connections = {}
	local player = game.Players.LocalPlayer
	
	local antiKnockbackActive = false
	local antiKnockbackConnection = nil
	local antiKnockbackTimer = nil
	
	local movementLoopConnection = nil
	local userInputService = game:GetService("UserInputService")
	local touchEnabled = userInputService.TouchEnabled
	local moveSpeed = 25
	local moveKeysPressed = {
		W = false,
		A = false,
		S = false,
		D = false
	}
	
	-- Для мобильного джойстика
	local mobileMoveVector = Vector2.new(0, 0)
	local virtualJoystick = nil
	local virtualJoystickConnection = nil
	
	local inputConnection = nil
	local inputEndedConnection = nil
	
	local function cleanup()
		for _, conn in ipairs(connections) do
			if typeof(conn) == "RBXScriptConnection" then
				if conn.Connected then
					conn:Disconnect()
				end
			end
		end
		connections = {}
	
		if antiKnockbackConnection then
			antiKnockbackConnection:Disconnect()
			antiKnockbackConnection = nil
		end
	
		if antiKnockbackTimer then
			task.cancel(antiKnockbackTimer)
			antiKnockbackTimer = nil
		end
	
		if movementLoopConnection then
			movementLoopConnection:Disconnect()
			movementLoopConnection = nil
		end
	
		if inputConnection then
			inputConnection:Disconnect()
			inputConnection = nil
		end
	
		if inputEndedConnection then
			inputEndedConnection:Disconnect()
			inputEndedConnection = nil
		end
	
		-- Очистка соединения с виртуальным джойстиком
		if virtualJoystickConnection then
			virtualJoystickConnection:Disconnect()
			virtualJoystickConnection = nil
		end
	
		mobileMoveVector = Vector2.new(0, 0)
		virtualJoystick = nil
	
		antiKnockbackActive = false
	
		moveKeysPressed.W = false
		moveKeysPressed.A = false
		moveKeysPressed.S = false
		moveKeysPressed.D = false
	end
	
	-- Функция для отслеживания встроенного виртуального джойстика
	local function setupMobileJoystickTracking()
		if not touchEnabled then return end
	
		-- Получаем виртуальный джойстик
		local playerGui = player:WaitForChild("PlayerGui")
	
		-- Ждем появления джойстика
		local function findVirtualJoystick()
			for _, gui in ipairs(playerGui:GetChildren()) do
				if gui:IsA("ScreenGui") and gui.Name:find("TouchGui") then
					local joystick = gui:FindFirstChild("TouchControlFrame")
					if joystick then
						local thumbstick = joystick:FindFirstChild("DynamicThumbstickFrame")
						if thumbstick then
							return thumbstick
						end
					end
				end
			end
			return nil
		end
	
		-- Поиск и подписка на движение джойстика
		virtualJoystick = findVirtualJoystick()
	
		if not virtualJoystick then
			-- Если джойстик не найден сразу, ждем его появления
			task.wait(1)
			virtualJoystick = findVirtualJoystick()
		end
	
		if virtualJoystick then
			-- Отслеживаем позицию джойстика через Heartbeat
			virtualJoystickConnection = game:GetService("RunService").Heartbeat:Connect(function()
				local thumbstick = virtualJoystick:FindFirstChild("Thumbstick")
				if thumbstick then
					local position = thumbstick.Position
					local size = thumbstick.Size
					local anchor = thumbstick.AnchorPoint
	
					-- Нормализуем позицию (-1 до 1)
					local x = (position.X.Scale + position.X.Offset / size.X.Offset) - 0.5
					local y = (position.Y.Scale + position.Y.Offset / size.Y.Offset) - 0.5
	
					-- Умножаем на 2 для диапазона -1..1
					x = x * 2
					y = y * 2
	
					-- Обновляем вектор движения
					mobileMoveVector = Vector2.new(x, y)
	
					-- Уменьшаем чувствительность для плавности
					if mobileMoveVector.Magnitude < 0.1 then
						mobileMoveVector = Vector2.new(0, 0)
					end
				end
			end)
		end
	end
	
	local function startAntiKnockback(character)
		if not enabled then return end
	
		local rootPart = character and character:FindFirstChild("HumanoidRootPart")
		if not rootPart then return end
	
		if antiKnockbackConnection then
			antiKnockbackConnection:Disconnect()
			antiKnockbackConnection = nil
		end
	
		if antiKnockbackTimer then
			task.cancel(antiKnockbackTimer)
			antiKnockbackTimer = nil
		end
	
		antiKnockbackActive = true
	
		antiKnockbackConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not enabled or not antiKnockbackActive then return end
			local currentVelocity = rootPart.Velocity
			rootPart.Velocity = Vector3.new(0, currentVelocity.Y, 0)
		end)
	
		antiKnockbackTimer = task.delay(0.3, function()
			if antiKnockbackConnection then
				antiKnockbackConnection:Disconnect()
				antiKnockbackConnection = nil
			end
			antiKnockbackActive = false
		end)
	end
	
	local function setupRagdollMovement(character, humanoid, rootPart)
		if not enabled then return end
	
		if movementLoopConnection then
			movementLoopConnection:Disconnect()
			movementLoopConnection = nil
		end
	
		if inputConnection then
			inputConnection:Disconnect()
			inputConnection = nil
		end
	
		if inputEndedConnection then
			inputEndedConnection:Disconnect()
			inputEndedConnection = nil
		end
	
		-- Очистка соединения с джойстиком
		if virtualJoystickConnection then
			virtualJoystickConnection:Disconnect()
			virtualJoystickConnection = nil
		end
	
		moveKeysPressed.W = false
		moveKeysPressed.A = false
		moveKeysPressed.S = false
		moveKeysPressed.D = false
		mobileMoveVector = Vector2.new(0, 0)
	
		-- Настройка управления в зависимости от устройства
		if touchEnabled then
			-- Используем встроенный джойстик
			setupMobileJoystickTracking()
		else
			-- ПК управление
			inputConnection = userInputService.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then return end
	
				local keyCode = input.KeyCode
				if keyCode == Enum.KeyCode.W then
					moveKeysPressed.W = true
				elseif keyCode == Enum.KeyCode.S then
					moveKeysPressed.S = true
				elseif keyCode == Enum.KeyCode.A then
					moveKeysPressed.A = true
				elseif keyCode == Enum.KeyCode.D then
					moveKeysPressed.D = true
				end
			end)
	
			inputEndedConnection = userInputService.InputEnded:Connect(function(input, gameProcessed)
				if gameProcessed then return end
	
				local keyCode = input.KeyCode
				if keyCode == Enum.KeyCode.W then
					moveKeysPressed.W = false
				elseif keyCode == Enum.KeyCode.S then
					moveKeysPressed.S = false
				elseif keyCode == Enum.KeyCode.A then
					moveKeysPressed.A = false
				elseif keyCode == Enum.KeyCode.D then
					moveKeysPressed.D = false
				end
			end)
	
			table.insert(connections, inputConnection)
			table.insert(connections, inputEndedConnection)
		end
	
		movementLoopConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not enabled then return end
	
			if not antiKnockbackActive and rootPart then
				local camera = workspace.CurrentCamera
				local cameraCFrame = camera.CFrame
				local moveDirection = Vector3.zero
	
				if touchEnabled then
					-- Используем вектор из встроенного джойстика
					if mobileMoveVector.Magnitude > 0.1 then
						moveDirection = moveDirection + (cameraCFrame.LookVector * mobileMoveVector.Y)
						moveDirection = moveDirection + (cameraCFrame.RightVector * mobileMoveVector.X)
					end
				else
					-- Используем клавиатурное управление
					if moveKeysPressed.W then
						moveDirection = moveDirection + cameraCFrame.LookVector
					end
					if moveKeysPressed.S then
						moveDirection = moveDirection - cameraCFrame.LookVector
					end
					if moveKeysPressed.A then
						moveDirection = moveDirection - cameraCFrame.RightVector
					end
					if moveKeysPressed.D then
						moveDirection = moveDirection + cameraCFrame.RightVector
					end
				end
	
				if moveDirection.Magnitude > 0 then
					moveDirection = moveDirection.Unit
	
					local horizontalMove = Vector3.new(moveDirection.X, 0, moveDirection.Z)
					if horizontalMove.Magnitude > 0 then
						horizontalMove = horizontalMove.Unit * moveSpeed
					end
	
					rootPart.Velocity = Vector3.new(
						horizontalMove.X,
						rootPart.Velocity.Y,
						horizontalMove.Z
					)
				end
			end
		end)
	
		table.insert(connections, movementLoopConnection)
	
		humanoid:ChangeState(Enum.HumanoidStateType.Running)
		humanoid.PlatformStand = false
	
		humanoid.WalkSpeed = moveSpeed
		humanoid.JumpPower = 50
	end
	
	local function activateSystems()
		local character = player.Character
		if not character then return end
	
		cleanup()
	
		if not character:FindFirstChild("Humanoid") then
			character:WaitForChild("Humanoid")
		end
	
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		local rootPart = character:FindFirstChild("HumanoidRootPart")
	
		if not humanoid or not rootPart then return end
	
		local ragdollRemote = game.ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Ragdoll"):WaitForChild("Ragdoll")
	
		local remoteConnection = ragdollRemote.OnClientEvent:Connect(function(action, manual)
			if not enabled then return end
	
			if action == "Make" or manual == "manualM" then
				startAntiKnockback(character)
				setupRagdollMovement(character, humanoid, rootPart)
	
			elseif action == "Destroy" or manual == "manualD" then
				if antiKnockbackConnection then
					antiKnockbackConnection:Disconnect()
					antiKnockbackConnection = nil
				end
				antiKnockbackActive = false
	
				humanoid.WalkSpeed = 16
				humanoid.JumpPower = 50
	
				if movementLoopConnection then
					movementLoopConnection:Disconnect()
					movementLoopConnection = nil
				end
			end
		end)
	
		table.insert(connections, remoteConnection)
	
		local stateConnection = humanoid.StateChanged:Connect(function(old, new)
			if not enabled then return end
	
			if new == Enum.HumanoidStateType.Physics then
				startAntiKnockback(character)
				setupRagdollMovement(character, humanoid, rootPart)
			end
		end)
	
		table.insert(connections, stateConnection)
	
		local charConnection = player.CharacterAdded:Connect(function(newCharacter)
			task.wait(1)
			if enabled then
				activateSystems()
			end
		end)
	
		table.insert(connections, charConnection)
	end
	
	-- Поддержка мобильного тапа
	if touchEnabled then
		local tapped = false
		local tapTime = 0
	
		button.TouchTap:Connect(function()
			enabled = not enabled
	
			if enabled then
				button.BackgroundTransparency = 0.4
				activateSystems()
			else
				button.BackgroundTransparency = 0.7
				cleanup()
			end
		end)
	
		-- Также поддерживаем TouchLongPress на случай проблем с Tap
		button.TouchLongPress:Connect(function()
			enabled = not enabled
	
			if enabled then
				button.BackgroundTransparency = 0.4
				activateSystems()
			else
				button.BackgroundTransparency = 0.7
				cleanup()
			end
		end)
	end
	
	-- Поддержка клика мышкой (для ПК)
	button.MouseButton1Click:Connect(function()
		enabled = not enabled
	
		if enabled then
			button.BackgroundTransparency = 0.4
			activateSystems()
		else
			button.BackgroundTransparency = 0.7
			cleanup()
		end
	end)
	
	button.BackgroundTransparency = 0.7
	
	script.Destroying:Connect(cleanup)
end
coroutine.wrap(MDAEPYQ_fake_script)()
local function MLONAA_fake_script() -- Button.drag 
	local script = Instance.new('LocalScript', Button)

	local frame = script.Parent
	local dragToggle = false
	local dragSpeed = 1
	local dragStart = Vector2.new(0, 0)
	local frameStart = Vector2.new(0, 0)
	
	local function updateInput(input)
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(
			frameStart.X.Scale, 
			frameStart.X.Offset + (delta.X * dragSpeed),
			frameStart.Y.Scale, 
			frameStart.Y.Offset + (delta.Y * dragSpeed)
		)
	end
	
	frame.InputBegan:Connect(function(input)
		-- Добавляем поддержку тача для мобильных устройств
		if input.UserInputType == Enum.UserInputType.MouseButton1 
			or input.UserInputType == Enum.UserInputType.Touch then
	
			dragToggle = true
			dragStart = input.Position
			frameStart = frame.Position
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragToggle = false
				end
			end)
		end
	end)
	
	frame.InputChanged:Connect(function(input)
		-- Обрабатываем движение мыши И тач-движение
		if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch) then
			updateInput(input)
		end
	end)
	
	local UserInputService = game:GetService("UserInputService")
	
	UserInputService.InputChanged:Connect(function(input)
		if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch) then
			updateInput(input)
		end
	end)
end
coroutine.wrap(MLONAA_fake_script)()
local function QHTWUD_fake_script() -- GuiMenu.GuiMENU 
	local script = Instance.new('LocalScript', GuiMenu)

	-- ИЗМЕНЕНО: Получаем GUI из CoreGui вместо PlayerGui
	local screenGui = game:GetService("CoreGui"):WaitForChild("ultimatePVP")
	local toggleButton = script.Parent
	local guiElement = screenGui:WaitForChild("Gui")
	
	local isVisible = false
	guiElement.Visible = isVisible
	
	local function toggleVisibility()
		isVisible = not isVisible
		guiElement.Visible = isVisible
	end
	
	toggleButton.MouseButton1Click:Connect(toggleVisibility)
end
coroutine.wrap(QHTWUD_fake_script)()
